---
title: "Manipulating GraphQL Queries Before Execution"
summary: "Lorem markdownum sacrorum sanguine ne utque contraria amata dederit, e.
Oraque est non tetigere; utque Venus."
date: "2023-03-05"
tags: ["graphql", "javascript", "hasura"]
image: "/images/js.png"
---

In a recent project, I needed to parse a GraphQL query generated by Hasura to do 3 things:
- Validate that the query was using an Aggregation query generated by Hasura and not any other type of query
- Ensure that any optional variables that were not specified by the user were pruned before execution
- Provider the user of the query the exact shape of the returned aggregation, eg count, sum.loan_amount, avg.balance, etc.


## Background

Hasura is a DAL (Data Access Layer) product that generates a single GraphQL endpoint for various data sources, including Databases, REST APIs as well as
other GraphQL schemas

In additional to providing access to the underlying data in these sources, it also generates simple aggregations in single tables as well as across
relationships.

I had a use case where we wanted to let customers create and consume these aggregations through a service. Here's a rough outline of the process

- Parse the string query into an AST using graphql-java
- Validate that it contrains an aggregation
- Store the expected result values. **count**, **sum.\<attribute\>**, etc
- Use the vistor pattern given via ASTTransformer to get the optional values
- Make sure that all requried values are provided
- Remove all the missing optional values from the argument as well and in any nested structures
- Execute query and return result to caller

## Prerequisites

I'm going to assume you have a graphql query that mimics an Aggregation query generated by Hasura. Because we aren't too concerned about schema validation 
and actually returning the result we'll mock those to keep this simple. That said, I'll provide you with a docker compose file as well as a script to run the
systems on your local machine to have the setup working completely

## Data

Assume you have 2 tables, 